# 技术类

* 加分：将笔试题答案提交到 github 上对下方仓库链接进行 Pull Request：

> https://github.com/creatshare-demos/CreatShare-5th-Anniversary.git

## 基础部分

1. C 标准定义的关键字都有哪些？分别有什么用？
 1>void:声明函数无返回值或无参
 2>char:1字节ASCII
 3>short:2字节补码
 4>int:4字节补码
 5>long:4字节补码
 6>float:4字节浮点
 7>double:8字节浮点
 8>signed:有符号数
 9>unsigned:无符号数
 10>struct:结构体声明
 11>union:共用体声明
 12>enum:枚举声明 
 13>typedef:声明类型别名 
 14>sizeof:得到特定类型或特定类型变量的大小 
 15>auto:指定为自动变量，由编译器自动分配及释放。通常在栈上分配 
 16>static:指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部
 17>register:指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数 
 18>extern:指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的韵蟮囊桓觥耙 谩? 
 19>const:与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变） 
 20>volatile:与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值
 21>if:条件语句 
 22>else:条件语句否定分支（与if连用）  
 23>switch：开关语句（多重分支语句）  
 24>case：开关语句中的分支标记 
 25>default:开关语句中的“其他”分治，可选
 26>for:for循环结构，for(1;2;3)4;的执行顺序为1->2->4->3->2...循环，其中2为循环条件  
 27>do:do循环结构，do 1 while(2);的执行顺序是1->2->1...循环，2为循环条件  
 28>while:while循环结构，while(1) 2;的执行顺序是1->2->1...循环，1为循环条件
 29>return:用在函数体中，返回特定值（或者是void值，即不返回值）  
 30>continue:结束当前循环，开始下一轮循环  
 31>break:跳出当前循环或switch结构  
 32>goto:无条件跳转语句
 
2. 以下式子的值为多少？为什么？
```
int Anniversary = (2016, ((0x01 << (int)2.0) + sizeof(char)));
```
	5  (1<<2)+1 = 4+1 = 5;
3. -0 和+0 在计算机里以什么形式存储？这样存储有必要吗？
	以补码的形式存在，-0其绝对值0各位取反为0xff ff ff ff(假设机器是32位)，然后加1，得到0。
所有-0在内存中存储是0x00000000。
4. struct 与 class 有什么区别？
	C中struct是结构体声明，结构体由成员组成；
	JAVA中class可以面向对象编程，类中可以有成员和方法。
5. 面向对象三大特性和五大原则分别是什么？对我们编程有什么启示？
	三大特性：封装，继承，多态

	封装，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

	继承，指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过 “继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用 基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。

	多态，是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

	五大原则：SPR, OCP, LSP, DIP, ISP

	单一职责原则SRP(Single Responsibility Principle)
	是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

	开放封闭原则OCP(Open－Close Principle)
	一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

	替换原则LSP(the Liskov Substitution Principle LSP)
	子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

	依赖原则DIP(the Dependency Inversion Principle DIP)
	具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能 造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。

	接口分离原则ISP(the Interface Segregation Principle ISP)
	模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来
	
6. 简述 OSI 七层模型和 TCP/IP 四层模型区别。并理解 HTTP 在其中的定位。
	1、OSI七层模型属于理论模型，TCP4层模型属于实际应用的工业标准模型；
	2、OSI划分的层次比TCP模型更多；
	3、从层次功能上分析：
	①前者应用层、表示层和会话层的功能对应TCP模型应用层功能；
	②前者传输层对应TCP模型传输层的功能；
	③前者网络层对应TCP模型网际层的功能
	④前者数据链路层和物理层对应TCP模型网络接口层功能。
7. 在 x86 系统下，有以下程序的运行结果是什么？在这个过程中系统都发生了什么？

```
#include <stdio.h>
#define HELLO “CREATSHARE %d!”
#define CREATSHARE(x) (x)
int main() {
    printf(HELLO,CREATSHARE(2016));
    return 0;
}
```
	CREATSHARE 2016!
	宏定义。
8. 在 x86 系统下，以下程序的运行结果是什么？为什么？

```
#include <stdio.h>
int main() {
    int a[4]={1,2,3,4};
    int *ptr1=(int *)(&a+1);
    int *ptr2=(int *)((int)a+1);
    printf("%x,%x",ptr1[-1],*ptr2);
    return 0;
}
```
	4,2
	&a+1=&a+sizeof(4*int)，因此&a+1指向的地址为&a[4]；所以ptr1指向&a[4]； ptr1-1=ptr-sizeof(int)，
	故ptr-1指向&a[3]。因此，ptr1[-1] <=> *(ptr1-1) <=> a[3] <=> 4。

	*ptr2 <=> *(a+1) <=> a[1] <=> 2

9. 编写一个函数，如果操作系统是大端模式返回0，小端模式返回1。
#include<stdio.h>
union node{
	int a;
	char b[4];
}t;

void main(void){
	t.a=1;
	printf("%d\n",t.b[0]);
}

10. 编写一个函数，参数中给定正整数 n 和 m，将1到n的这n个整数按字典排序之后，返回其中的第 m 个数字。对于n=11，m=4，按字典序排列依次为1，10，11，2，3，4，5，6，7，8，9。因此第4个数字为2。

## 服务端部分

1. 列出常见的关系型数据库和非关系型数据库。
	关系型数据库：SQLite、Oracle、mysql
	非关系型数据库：MongoDb、redis、HBase
2. 谈谈你对数据库和数据仓库的理解。
	数据库是一个装数据（信息的原材料）的地方。 
	数据仓库是一种系统，这种系统也是用数据库装东西。 
 区别：1.数据库只存放在当前值，数据仓库存放历史值；
      2.数据库内数据是动态变化的，只要有业务发生，数据就会被更新，而数据仓库则是静态的历史数据，只能定期添加、刷新；
      3.数据库中的数据结构比较复杂，有各种结构以适合业务处理系统的需要，而数据仓库中的数据结构则相对简单；
      4.数据库中数据访问频率较高，但访问量较少，而数据仓库的访问频率低但访问量却很高；
      5.数据库中数据的目标是面向业务处理人员的，为业务处理人员提供信息处理的支持，而数据仓库则是面向高层管理人员的，为其提供决策支持；
      6.数据库在访问数据时要求响应速度快，其响应时间一般在几秒内，而数据仓库的响应时间则可长达数几小时。
3. 谈谈你对对象关系型映射(orm)的理解。
	对象关系映射，简称ORM，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。
	面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。
	对象关系映射ORM提供了概念性的、易于理解的模型化数据的方法。ORM方法论基于三个核心原则： 简单：以最基本的形式建模数据。 传达性：数据库结构被任何人都能理解的语言文档化。 精确性：基于数据模型创建正确标准化的结构。 典型地，建模者通过收集来自那些熟悉应用程序但不熟练的数据建模者的人的信息开发信息模型。建模者必须能够用非技术企业专家可以理解的术语在概念层次上与数据结构进行通讯。建模者也必须能以简单的单元分析信息，对样本数据进行处理。ORM专门被设计为改进这种联系。
4. 区分进程和线程。
	进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同，线程又称为轻量级进程，线程是由进程生成的。
5. 请用一个例子表明全局对象的缺点。
	缺点：
	1.容易造成命名冲突;
	2.当值不正确或者出错时，很难确定是哪个函数更改过这个变量;
	3.不支持多线程.
6. 区分 Stringbuffer 与 Stringbuilder。
	1.  在执行速度方面的比较：StringBuilder >  StringBuffer   
	2.  StringBuffer与StringBuilder，他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度就快了。
	3.  StringBuilder：线程非安全的
　	   StringBuffer：线程安全的
 	当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。
使用的总结：1.单线程操作字符串缓冲区 下操作大量数据  StringBuilder
　　　　　　2.多线程操作字符串缓冲区 下操作大量数据  StringBuffer
7. 谈谈你对 TCP 三次握手中 TIME_WAIT 和 CLOSE_WAIT 状态的理解。
	常用的三个状态是：ESTABLISHED 表示正在通信，TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。
TCP协议规定，对于已经建立的连接，网络双方要进行四次握手才能成功断开连接，如果缺少了其中某个步骤，将会使连接处于假死状态，连接本身占用的资源不会被释放。网络服务器程序要同时管理大量连接，所以很有必要保证无用连接完全断开，否则大量僵死的连接会浪费许多服务器资源。在众多TCP状态中，最值得注意的状态有两个：CLOSE_WAIT和TIME_WAIT。  
TIME_WAIT 
	TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。  由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接
CLOSE_WAIT
	CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。
为什么需要 TIME_WAIT 状态？
	假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，client必须进入 TIME_WAIT 状态，因为client可能面 临重发最终ACK的情形。
为什么 TIME_WAIT 状态需要保持 2MSL 这么长的时间？
	如果 TIME_WAIT 状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP实现必须防止某个连接的重复报文在连接终止后出现，所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被 丢弃。建立第二个连接的时候，不会混淆。
 	TIME_WAIT 和CLOSE_WAIT状态socket过多
如果服务器出了异常，百分之八九十都是下面两种情况：
1.服务器保持了大量TIME_WAIT状态
2.服务器保持了大量CLOSE_WAIT状态，简单来说CLOSE_WAIT数目过大是由于被动关闭连接处理不当导致的。
8. 简述在 epoll 的水平触发下，当 socket  可写的时候，会不停的触发写事件的原因。
	Level_triggered(水平触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上次没读写完的文件描述符上继续读写
若socket fd 可写，每次epoll_wait都会返回该fd，会造成CPU占用100%的毛病
第一种最普遍的解决方式：
	需要向socket写数据的时候才把socket加入epoll，等待可写事件。
接受到可写事件后，调用write或者send发送数据。
当所有数据都写完后，把socket移出epoll。
这种方式的缺点是，即使发送很少的数据，也要把socket加入epoll，写完后在移出epoll，有一定操作代价。
一种改进的解决方式：
	开始不把socket加入epoll，需要向socket写数据的时候，直接调用write或者send发送数据。如果返回EAGAIN，把socket加入epoll，在epoll的驱动下写数据，全部数据发送完毕后，再移出epoll。
这种方式的优点是：数据不多的时候可以避免epoll的事件处理，提高效率。
9. 简述打开TCP套接字有很大开销的原因。
	存在三种套接字：流式套接字(SOCK_STREAM)、数据报套接字(SOCK_DGRAM)和原始套接字(SOCK_RAW)。
TCP套接字工作流程：
首先，服务器端启动进程，调用Socket创建一个基于TCP协议的流套接字描述符。
其次，服务进程调用bind命名套接字，将套接字描述符绑定到本地地址和本地端口上。
再次，服务器端调用listen，开始侦听客户端的Socket连接请求。
接下来，客户端创建套接字描述符，并且调用connect向服务器端提交连接请求。服务器端接收到客户端连接请求后，调用accept，接受并创建一个新的套接字描述符与客户端建立连接，然后原套接字描述符继续侦听客户端的连接请求。
客户端与服务器端新套接字进行数据传输，调用write或send向对方发送数据，调用read或recv接收数据。
在数据交流完毕后，双方调用close或者shutdown关闭套字。
10. 以下两道编程题二选一，全做加分。

10.1. 使用信号量实现有限缓冲区的生产者和消费者问题。

10.2. 搭建开发环境，本地环境用 Post 方法向后台发送 Json 数据。如果是以下内容则返回“Happy 5 Anniversary!”，否则返回“error”。

```
{
    name: “CreatShare”
    anniversary: 5,
    year: 2016
}
```
